複雑性の発生源は「1つのラリー状態を、複数の“並行する表現”で持っている」点にあります。あなたが貼った思考プロセスも、まさにそこに引っ張られて迷子になっています。

以下、どこが複雑性を生み、どう切れば（＝考える時間を短くできるか）を、構造として整理します。

---

## 複雑性を生んでいる中心

### 1) “ラリーの実体”が1つに定まっていない

現状のラリーが、少なくともこの3系統で表現されています。

- `rallySteps`（確定ショット列）
- `shotPhase`（入力途中の保留状態）
- `finalShot`（「最後の1本」扱いの特例）

ここが「同じ出来事を別の変数が別名で持つ」構造になっていて、**同期ズレ**と**二重計上**が起きやすい。

典型的なバグ形はこれです：

- `rallySteps` にすでに “3打目” が入っているのに
- `finalShot` も同じ “3打目相当” を生成してしまう
  → アニメ側が「steps再生 + finalShot再生」をやって **2打目がもう一回／どれかが重複** に見える

あなたのログでも「finalShotがどのケースで立つのか」「shotPhaseと共存しうるのか」で延々と追跡が発生している。これが時間を吸います。

---

### 2) “入力の状態機械” と “再生の状態機械” が混線している

本来、編集モードの “保留” は、再生の列生成に影響してはいけないのに、

- 再生時に `shotPhase` を参照して `finalShot` をでっち上げる（または表示する）
- さらに `ShotPreviewPath` / `SvgLayer` のような **描画レイヤー** がモードをまたいで存在する

これがあると、ユーザー視点では

- 「2打目が決まる（プレビューが出る）」
- 「2打目が再生される（本アニメが走る）」

のように **“決定表示” と “再生” が同じショットを2回見せる** 形になり、報告内容と一致しやすいです。

---

### 3) “列（sequence）” を動的に生成している（しかも複数箇所で）

アニメーションが「何を何番目に再生するか」が、単一の `sequence` になっていないはずです。

- ループ：`rallySteps` を順に再生
- 追加セクション：`finalShot` があれば最後に再生
- さらにプレビュー/パス描画が別ロジック

この時点で、問題を追うには「3つの列生成規則」を頭に保持する必要があり、規模の割に思考コストが跳ね上がります。

---

## 「2打目がもう一度再生」に直結しやすい具体パターン

あなたの推測群の中で、実際に“再生順が 1→2→2→3 に見える”を生むのはだいたいこの2つです。

### A) `rallySteps` の最後と `finalShot` が同じショット（または同じ起点終点）を指す

- `finalShot` の生成条件が広すぎる
- `finalShot` をクリアすべきイベントで残っている
- `shotPhase` から `finalShot` を導出しているが、すでに確定済みの3打目がある

**チェック方法（最短）**
再生開始時に、必ず1回だけログ出し：

- `rallySteps.length`
- `finalShot` の有無
- `sequence = [...rallySteps, ...(finalShot? [finalShot] : [])]` の長さ
- 各要素の `hitFrom / bounceAt / returnAt`（または識別キー）

ここで `sequence` が 4 になってたら、再生が増えて当然です。

---

### B) アニメは正しいが、「表示レイヤーが同じショットを2回見せている」

- `ShotPath`（確定パス）と `ShotPreviewPath`（保留プレビュー）が play 中も残る
- ボールは 1→2→3 だが、パス表示が “2が確定/強調” を挟む

**チェック方法（最短）**
play モード中に描画されるコンポーネントを絞る。
`SvgLayer` で `mode === 'play'` のときに

- 何を render しているか（ShotPath / ShotPreviewPath / Marker 等）

を列挙し、play 中は “ボール＋最低限の補助表示だけ” に落とすと、ユーザーの「2がもう一回」体感が消えるケースがあります。

---

## なぜ「規模の割に悩む」のか（設計上の根）

この問題の本質は「ショット列の確定」と「ショット列の再生」が、同じ状態（`rallySteps/shotPhase/finalShot`）を取り合っていることです。

- 編集：途中状態が必要（awaiting 等）
- 再生：途中状態は不要（確定列だけ欲しい）

なのに、再生側が途中状態から“最後の1本”を合成してしまうから、**編集の複雑さがそのまま再生に漏れて**、追跡が地獄になります。

---

## 複雑性を削る最短の設計修正（方向性）

### 1) 再生は「単一の sequence」だけを見る

再生開始時に必ずこれを作って固定する：

- `sequence: ShotStep[]`（これだけ）

そして play 中は `shotPhase` や `finalShot` を参照しない。
（必要なら “編集状態からsequenceを作る関数” を1箇所に閉じる）

### 2) `finalShot` は “状態” ではなく “sequence生成の結果” に寄せる

`finalShot` という別名の状態を永続させるほど、同期問題が出ます。

- `rallySteps + (shotPhase.awaiting ? derivedFinal : none)`
  みたいに **導出値**にするか、
- “最後のショットも ShotStep として rallySteps に入れる” に統一する（終端フラグを持つ）

どちらかに寄せると、二重再生の余地が減ります。

### 3) play 中はプレビューを描画しない

UIの体感バグの可能性を最短で潰せます。
「再生」モードは出力専用にするのが鉄則です。

---

## Claude Codeに投げるなら、この指示が効きます（短いプロンプト案）

- 再生開始時点で `sequence` を1回だけ生成し、その `sequence` だけでアニメするように変更して。
- `sequence` は `rallySteps` と、必要なら `shotPhase(awaiting)` から導出した最後の1本を結合して作る。ただし **重複（同等ショット）があれば必ず排除**。
- play モード中は `ShotPreviewPath` 等の編集補助レイヤーを render しない（または透明化）。
- 再生開始時に `sequence` をログ出しして、3打目があるのに `sequence` が4になっていないことを確認する。

---

必要なら、次にあなたが貼ったファイル一覧から「最初に見るべき順」をこちらで決め打ちします（`useRallyAnimation.ts` / `SvgLayer.tsx` / `ShotPreviewPath.tsx` / `PlayPanel.tsx` / `gameReducer.ts` の順が濃厚）。ただ、今の時点でも「複雑性の核」は上の3点（並行状態・混線・列生成の分散）でほぼ確定です。
